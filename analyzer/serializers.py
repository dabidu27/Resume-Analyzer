from rest_framework import serializers
from .models import ResumeAnalyzer
from .services.analysis import analyze_resume
from django.contrib.auth.models import User

class ResumeAnalyzerSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = ResumeAnalyzer
        fields = ['user', 'id', 'resume_text', 'job_text', 'match_score', 'matched_keywords', 'created_at']
        read_only_fields = ['user', 'id', 'match_score', 'matched_keywords', 'created_at'] #we mark them as read only so they are not expected in the request body, as they are computed by us or generated by django/the system
    
    def validate(self, data): #we are moving request body data validation from view to serializer; this method runs when we call serializer.is_valid()

        resume = data.get('resume_text')
        job = data.get('job_text')

        if not resume or not job:

            raise serializers.ValidationError('resume_text and job_text are required')
        
        return data
    
    def create(self, validated_data): #we are moving object creation from view to serializer; this method runs when we call serializer.save()
        #we modify the serializer such that every analysis now belongs authomatically to an authenticated user  
        user = self.context['request'].user #get the user that made the request
        #we cannot use request.user directly in the serializier, only in the view
        resume_text = validated_data['resume_text']
        job_text = validated_data['job_text']

        score, matched_keywords = analyze_resume(resume_text=resume_text, job_text=job_text)

        return ResumeAnalyzer.objects.create(user = user, resume_text = resume_text, job_text = job_text, match_score = score, matched_keywords = matched_keywords)


class RegistrationSerializer(serializers.ModelSerializer):

    password = serializers.CharField(write_only = True) #we override the password field and make it write_only so it is never returned in responses and leaked

    class Meta:

        model = User
        fields = ['username', 'password']

    def create(self, validated_data):

        user = User.objects.create_user(username = validated_data['username'], password = validated_data['password'])
        #create_user instead of create automatically hashes the password
        return user